/*
 * Qiskit Runtime API
 *
 * The Qiskit Runtime API description
 *
 * The version of the OpenAPI document: 0.31.10
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// JobResponse : A job
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct JobResponse {
    /// Identifier assigned to the job
    #[serde(rename = "id")]
    pub id: String,
    /// &ast;&ast;Warning:&ast;&ast; While this parameter is not currently required for requests, specifying it is strongly encouraged. Running an ISA circuit on a backend that has a different instruction set will result in an error. The backend parameter will be required in a future release.  The backend on which to run the program.  If no backend is specified, the job is sent to the backend with the shortest queue that you have access to.
    #[serde(rename = "backend", skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    #[serde(rename = "state")]
    pub state: Box<models::JobState>,
    /// Current status of the job
    #[serde(rename = "status")]
    pub status: Status,
    /// Parameters used to execute the job
    #[serde(rename = "params", skip_serializing_if = "Option::is_none")]
    pub params: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[serde(rename = "program")]
    pub program: Box<models::JobResponseProgram>,
    /// UTC timestamp for when the job was created
    #[serde(rename = "created")]
    pub created: String,
    /// Name and tag of the image to use when running a program (IBM Quantum channel users only)
    #[serde(rename = "runtime", skip_serializing_if = "Option::is_none")]
    pub runtime: Option<String>,
    /// Cost of the job as the estimated time it should take to complete (in seconds). Should not exceed the cost of the program. If the provided value exceeds the maximum, it will be capped at that value.
    #[serde(rename = "cost")]
    pub cost: i32,
    /// List of job or program tags
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    #[serde(rename = "remote_storage", skip_serializing_if = "Option::is_none")]
    pub remote_storage: Option<Box<models::JobResponseRemoteStorage>>,
    /// Identifier of the session that the job is a part of
    #[serde(rename = "session_id", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
    /// The id of the user submitted the job
    #[serde(rename = "user_id", skip_serializing_if = "Option::is_none")]
    pub user_id: Option<String>,
    #[serde(rename = "usage", skip_serializing_if = "Option::is_none")]
    pub usage: Option<Box<models::Usage>>,
    /// When set to true, input parameters are not returned, and the results can only be read once. After the job is completed, input parameters are deleted from the service. After the results are read, they are deleted from the service. When set to false, the input parameters and results follow the standard retention behavior of the API. Only returned in the response if the value is true, otherwise it is omitted.
    #[serde(rename = "private", skip_serializing_if = "Option::is_none")]
    pub private: Option<bool>,
    /// Estimated usage in seconds
    #[serde(
        rename = "estimated_running_time_seconds",
        skip_serializing_if = "Option::is_none"
    )]
    pub estimated_running_time_seconds: Option<f64>,
    /// The ID of the calibration used for the job
    #[serde(rename = "calibration_id", skip_serializing_if = "Option::is_none")]
    pub calibration_id: Option<String>,
}

impl JobResponse {
    /// A job
    pub fn new(
        id: String,
        state: models::JobState,
        status: Status,
        program: models::JobResponseProgram,
        created: String,
        cost: i32,
    ) -> JobResponse {
        JobResponse {
            id,
            backend: None,
            state: Box::new(state),
            status,
            params: None,
            program: Box::new(program),
            created,
            runtime: None,
            cost,
            tags: None,
            remote_storage: None,
            session_id: None,
            user_id: None,
            usage: None,
            private: None,
            estimated_running_time_seconds: None,
            calibration_id: None,
        }
    }
}
/// Current status of the job
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "Queued")]
    Queued,
    #[serde(rename = "Running")]
    Running,
    #[serde(rename = "Completed")]
    Completed,
    #[serde(rename = "Cancelled")]
    Cancelled,
    #[serde(rename = "Cancelled - Ran too long")]
    CancelledRanTooLong,
    #[serde(rename = "Failed")]
    Failed,
}

impl Default for Status {
    fn default() -> Status {
        Self::Queued
    }
}
